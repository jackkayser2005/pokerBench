<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>AI Poker Lab — Elo Over Time</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link rel="stylesheet" href="/web/app.css?v=5"/>
  <link rel="icon" href="/web/favicon.svg" type="image/svg+xml"/>
    <script>
    const palette = ['#4df6b4', '#76b0ff', '#ffd166', '#f08cf0', '#ff6d6d', '#9de7ff', '#c4f98b', '#b59bff'];
    const state = {
      dims: { width: 1100, height: 440 },
      pad: { top: 48, right: 70, bottom: 64, left: 78 },
      plots: [],
      flat: [],
      flatSorted: [],
      fullSeries: [],
      currentSeries: [],
      companies: [],
      selectedCompany: 'all',
      resizeTimer: null,
      resizeBound: null,
      lastHoverKey: null
    };
    const dateFormatter = new Intl.DateTimeFormat(undefined, { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
    const shortDate = new Intl.DateTimeFormat(undefined, { month: 'short', day: 'numeric' });
    const $ = (sel) => document.querySelector(sel);

    const COMPANY_ICON_DATA = {
      openai:      { path: '/web/img/openai.svg', alt: 'OpenAI' },
      deepseek:    { path: '/web/img/deepseek-color.svg', alt: 'DeepSeek' },
      xai:         { path: '/web/img/xai.svg', alt: 'xAI' },
      anthropic:   { path: '/web/img/anthropic.svg', alt: 'Anthropic' },
      meta:        { path: '/web/img/meta.svg', alt: 'Meta' },
      google:      { path: '/web/img/google.svg', alt: 'Google' },
      mistral:     { path: '/web/img/mistral.svg', alt: 'Mistral' },
      groq:        { path: '/web/img/groq.svg', alt: 'Groq' },
      together:    { path: '/web/img/together.svg', alt: 'Together' },
      perplexity:  { path: '/web/img/perplexity.svg', alt: 'Perplexity' },
      azure:       { path: '/web/img/azure.svg', alt: 'Azure' },
      openrouter:  { path: '/web/img/openrouter.svg', alt: 'OpenRouter' },
      cohere:      { path: '/web/img/cohere.svg', alt: 'Cohere' },
      fireworks:   { path: '/web/img/fireworks.svg', alt: 'Fireworks' },
      qwen:        { path: '/web/img/qwen.svg', alt: 'Qwen' },
    };

    const COMPANY_ALIAS = {
      llama: 'meta',
      llamaii: 'meta',
      grok: 'xai',
      'xai': 'xai',
      'x.ai': 'xai',
      gemini: 'google',
    };

    const COMPANY_LABELS = {
      openai: 'OpenAI',
      deepseek: 'DeepSeek',
      xai: 'xAI',
      anthropic: 'Anthropic',
      meta: 'Meta',
      google: 'Google',
      mistral: 'Mistral',
      groq: 'Groq',
      together: 'Together',
      perplexity: 'Perplexity',
      azure: 'Azure',
      openrouter: 'OpenRouter',
      cohere: 'Cohere',
      fireworks: 'Fireworks',
      qwen: 'Qwen',
    };

    function slugifyCompany(value) {
      return String(value || '')
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '');
    }

    function prettyCompanyName(value) {
      const slug = slugifyCompany(value);
      if (COMPANY_LABELS[slug]) return COMPANY_LABELS[slug];
      if (!value) return '';
      return String(value)
        .replace(/[_-]+/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .replace(/\b\w/g, ch => ch.toUpperCase());
    }

    function extractOpenRouterVendor(model) {
      if (!model) return '';
      const match = String(model).match(/openrouter[\\/:|-]+([A-Za-z0-9_.-]+)/i);
      if (match && match[1]) return match[1];
      const parts = String(model)
        .split(/[\\/:]/)
        .map(part => part.trim())
        .filter(Boolean);
      if (!parts.length) return '';
      const idx = parts.findIndex(part => part.toLowerCase() === 'openrouter');
      if (idx >= 0) {
        if (parts[idx + 1]) return parts[idx + 1];
        if (idx > 0) return parts[idx - 1];
      }
      return '';
    }

    function resolveCompanyMeta(company, model) {
      const rawCompany = String(company || '').trim();
      const lowerCompany = rawCompany.toLowerCase();
      const modelStr = String(model || '').trim();
      const lowerModel = modelStr.toLowerCase();
      let vendor = '';
      if (!rawCompany || lowerCompany === 'openrouter') {
        vendor = extractOpenRouterVendor(modelStr);
      }
      const fallback = lowerModel.includes('openrouter') ? 'OpenRouter' : 'OpenAI';
      const primary = vendor || rawCompany || fallback;
      let slug = slugifyCompany(primary);
      if (slug === 'openrouter' && vendor) {
        slug = slugifyCompany(vendor);
      }
      if (COMPANY_ALIAS[slug]) slug = COMPANY_ALIAS[slug];
      if (!slug) slug = 'openai';
      const labelSource = vendor || rawCompany || primary;
      const label = COMPANY_LABELS[slug] || prettyCompanyName(labelSource) || 'OpenAI';
      return { slug, label };
    }

    function canonicalCompany(company, model) {
      return resolveCompanyMeta(company, model).label;
    }

    function companyIconMarkup(company, model) {
      const meta = resolveCompanyMeta(company, model);
      const icon = COMPANY_ICON_DATA[meta.slug];
      if (icon) {
        return `<img class="org-icon" src="${icon.path}" alt="${icon.alt}"/>`;
      }
      return '<span class="org-icon org-icon--dot" aria-hidden="true"></span>';
    }

    function createIconElement(markup) {
      if (!markup) return null;
      const tpl = document.createElement('template');
      tpl.innerHTML = markup.trim();
      return tpl.content.firstElementChild;
    }

    function trimModelName(s = '') {
      s = s.trim().replace(/^"+|"+$/g, '');
      const parts = s.split(/[\/:@]/).filter(Boolean);
      if (parts.length) s = parts[parts.length - 1];
      if (s.length > 42) s = s.slice(0, 42) + '…';
      return s;
    }

    function normalizeLegendMeta(entry) {
      if (!entry) return { label: '', model: '', company: '' };
      const label = String(entry.label || '').trim().toUpperCase();
      const model = String(entry.model || '').trim();
      const company = String(entry.company || '').trim();
      return { label, model, company };
    }

    function buildLegendEntry(slot, meta) {
      const host = document.createElement('div');
      host.className = 'match-legend__item';
      const color = slot === 'A' ? '#39d98a' : '#d6c29b';
      host.style.setProperty('--legend-color', color);

      const swatch = document.createElement('span');
      swatch.className = 'match-legend__swatch';
      swatch.style.background = color;
      host.appendChild(swatch);

      const details = document.createElement('div');
      details.className = 'match-legend__details';

      const slotEl = document.createElement('span');
      slotEl.className = 'match-legend__slot';
      slotEl.textContent = slot;
      details.appendChild(slotEl);

      const infoWrap = document.createElement('div');
      infoWrap.className = 'match-legend__info';
      const hasMeta = Boolean((meta.model || '').trim() || (meta.company || '').trim());
      if (hasMeta) {
        const iconMarkup = companyIconMarkup(meta.company, meta.model);
        const iconEl = createIconElement(iconMarkup);
        if (iconEl) infoWrap.appendChild(iconEl);
      }

      const textEl = document.createElement('span');
      textEl.className = 'match-legend__text';
      const trimmedModel = trimModelName(meta.model || '');
      const pieces = [];
      if (trimmedModel) pieces.push(trimmedModel);
      let company = '';
      if ((meta.company || '').trim() || (meta.model || '').trim()) {
        company = canonicalCompany(meta.company, meta.model);
      }
      const lowerModel = trimmedModel.toLowerCase();
      const lowerCompany = company.toLowerCase();
      const includeCompany = Boolean(company) && !lowerModel.includes(lowerCompany);
      if (includeCompany) pieces.push(company);
      const hasInfo = pieces.length > 0;
      textEl.textContent = hasInfo ? pieces.join(' · ') : 'Awaiting matchup';
      if (!hasInfo) textEl.classList.add('match-legend__text--empty');
      infoWrap.appendChild(textEl);

      details.appendChild(infoWrap);
      host.appendChild(details);

      return { element: host, hasInfo };
    }

    async function loadMatchLegend() {
      const host = document.getElementById('eloMatchLegend');
      if (!host) return;
      host.innerHTML = '';
      host.hidden = true;
      try {
        const res = await fetch('/api/last-match');
        if (!res.ok) return;
        const data = await res.json();
        const participants = Array.isArray(data?.participants) ? data.participants : [];
        const map = new Map();
        participants.forEach(p => {
          const { label, model, company } = normalizeLegendMeta(p);
          if (label) map.set(label, { label, model, company });
        });
        const slots = ['A', 'B'];
        const entries = slots.map(slot => buildLegendEntry(slot, map.get(slot) || { label: slot, model: '', company: '' }));
        const hasLegend = entries.some(entry => entry.hasInfo);
        if (!hasLegend) return;
        entries.forEach(entry => host.appendChild(entry.element));
        host.hidden = false;
      } catch (err) {
        if (window.console && typeof window.console.debug === 'function') {
          window.console.debug('legend load failed', err);
        }
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      highlightNav();
      load();
      loadMatchLegend();
    });

    function highlightNav() {
      document.querySelectorAll('.topnav a').forEach(a => {
        try {
          const last = a.getAttribute('href').split('/').pop();
          if (location.pathname.endsWith(last)) a.classList.add('active');
        } catch {}
      });
    }

    function color(idx) {
      return palette[idx % palette.length];
    }

    function groupByBot(rows) {
      const map = new Map();
      rows.forEach(r => {
        if (r.bot_id == null) return;
        const model = (r.model || '').trim();
        const metaInfo = resolveCompanyMeta(r.company, model);
        const companyLabel = metaInfo.label;
        const companySlug = metaInfo.slug || 'openai';
        let entry = map.get(r.bot_id);
        if (!entry) {
          entry = {
            botId: r.bot_id,
            meta: {
              model,
              company: companyLabel,
              companyKey: companySlug,
              iconMarkup: companyIconMarkup(r.company, model)
            },
            pts: []
          };
          map.set(r.bot_id, entry);
        } else {
          entry.meta.model = model || entry.meta.model;
          entry.meta.company = companyLabel;
          entry.meta.companyKey = companySlug;
          entry.meta.iconMarkup = companyIconMarkup(r.company, model || entry.meta.model);
        }
        const when = new Date(r.when);
        if (Number.isNaN(when.getTime())) return;
        entry.pts.push({ t: when, elo: Number(r.elo || 0) });
      });
      map.forEach(entry => entry.pts.sort((a, b) => a.t - b.t));
      return Array.from(map.values());
    }

    function buildCompanyIndex(series) {
      const map = new Map();
      series.forEach(entry => {
        const key = entry.meta.companyKey || 'openai';
        if (!map.has(key)) {
          map.set(key, {
            key,
            label: entry.meta.company,
            iconMarkup: entry.meta.iconMarkup
          });
        }
      });
      return Array.from(map.values()).sort((a, b) => a.label.localeCompare(b.label));
    }

    function draw(series) {
      const chartWrap = document.querySelector('.elo-chart');
      if (!chartWrap) return;
      const svg = document.getElementById('chart');
      const tooltip = chartWrap.querySelector('.chart-tooltip');
      const tooltipTime = tooltip.querySelector('.chart-tooltip__time');
      const tooltipSeries = tooltip.querySelector('.chart-tooltip__series');
      const legend = document.getElementById('legend');

      state.currentSeries = Array.isArray(series) ? series.slice() : [];

      const mk = (tag) => document.createElementNS('http://www.w3.org/2000/svg', tag);

      svg.innerHTML = '';
      legend.innerHTML = '';
      tooltip.classList.remove('visible');

      const rect = chartWrap.getBoundingClientRect();
      const width = Math.max(720, rect.width || state.dims.width);
      const height = Math.max(420, Math.min(width * 0.56, (window.innerHeight || 900) * 0.7));
      state.dims.width = width;
      state.dims.height = height;

      const pad = { ...state.pad };
      if (width < 980) {
        pad.left = 70;
        pad.right = 70;
      }
      if (width < 780) {
        pad.left = 56;
        pad.right = 56;
        pad.bottom = 74;
      }

      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.style.cursor = 'crosshair';

      state.plots = [];
      state.flat = [];
      state.flatSorted = [];
      state.lastHoverKey = null;

      const allPts = [];
      series.forEach(entry => entry.pts.forEach(p => allPts.push(p)));
      if (!allPts.length) {
        const msg = mk('text');
        msg.setAttribute('x', String(pad.left));
        msg.setAttribute('y', String(height / 2));
        msg.setAttribute('fill', '#5b7089');
        msg.setAttribute('font-size', '14');
        msg.textContent = state.selectedCompany !== 'all'
          ? 'No duels logged yet for this company.'
          : 'No duels logged yet.';
        svg.appendChild(msg);
        return;
      }

      const times = allPts.map(p => p.t.getTime());
      const uniqueTimes = Array.from(new Set(times)).sort((a, b) => a - b);
      const indexByTime = new Map();
      uniqueTimes.forEach((ms, idx) => indexByTime.set(ms, idx));
      const elos = allPts.map(p => p.elo);
      const rawMin = Math.min(...elos);
      const rawMax = Math.max(...elos);
      const yPad = Math.max(10, (rawMax - rawMin) * 0.08);
      let yMin = rawMin - yPad;
      let yMax = rawMax + yPad;
      if (yMin === yMax) {
        yMin -= 50;
        yMax += 50;
      }
      const maxIndex = Math.max(1, uniqueTimes.length - 1);
      const xForIndex = (idx) => pad.left + (idx * (width - pad.left - pad.right)) / maxIndex;
      const x = (time) => {
        const idx = indexByTime.get(time);
        return xForIndex(idx == null ? 0 : idx);
      };
      const y = (val) => height - pad.bottom - ((val - yMin) * (height - pad.top - pad.bottom)) / (yMax - yMin);

      const defs = mk('defs');
      const bgGrad = mk('linearGradient');
      bgGrad.setAttribute('id', 'chart-bg');
      bgGrad.setAttribute('x1', '0');
      bgGrad.setAttribute('x2', '0');
      bgGrad.setAttribute('y1', '0');
      bgGrad.setAttribute('y2', '1');
      const bgStop1 = mk('stop'); bgStop1.setAttribute('offset', '0%'); bgStop1.setAttribute('stop-color', 'rgba(20,34,52,.72)');
      const bgStop2 = mk('stop'); bgStop2.setAttribute('offset', '100%'); bgStop2.setAttribute('stop-color', 'rgba(12,18,28,.92)');
      bgGrad.appendChild(bgStop1); bgGrad.appendChild(bgStop2);
      defs.appendChild(bgGrad);
      svg.appendChild(defs);

      const bg = mk('rect');
      bg.setAttribute('x', '0');
      bg.setAttribute('y', '0');
      bg.setAttribute('width', String(width));
      bg.setAttribute('height', String(height));
      bg.setAttribute('fill', 'url(#chart-bg)');
      svg.appendChild(bg);

      const grid = mk('g');
      grid.setAttribute('stroke', 'rgba(255,255,255,.08)');
      grid.setAttribute('stroke-width', '1');
      grid.setAttribute('fill', 'none');

      const yTicks = 6;
      for (let i = 0; i <= yTicks; i++) {
        const value = yMin + (i * (yMax - yMin)) / yTicks;
        const yy = y(value);
        const line = mk('line');
        line.setAttribute('x1', String(pad.left));
        line.setAttribute('x2', String(width - pad.right));
        line.setAttribute('y1', String(yy));
        line.setAttribute('y2', String(yy));
        line.setAttribute('opacity', i === yTicks ? '0.45' : '0.25');
        grid.appendChild(line);

        const label = mk('text');
        label.setAttribute('x', String(pad.left - 16));
        label.setAttribute('y', String(yy + 4));
        label.setAttribute('text-anchor', 'end');
        label.setAttribute('fill', '#6f8099');
        label.setAttribute('font-size', '11');
        label.textContent = Math.round(value).toString();
        svg.appendChild(label);
      }

      const tickCount = uniqueTimes.length > 1 ? Math.min(6, uniqueTimes.length - 1) : uniqueTimes.length;
      const tickIndexes = [];
      if (!uniqueTimes.length) {
        // nothing to render
      } else if (tickCount <= 1) {
        tickIndexes.push(0);
        if (uniqueTimes.length > 1) tickIndexes.push(uniqueTimes.length - 1);
      } else {
        for (let i = 0; i <= tickCount; i++) {
          const idx = Math.round((i * (uniqueTimes.length - 1)) / Math.max(1, tickCount));
          tickIndexes.push(Math.min(uniqueTimes.length - 1, Math.max(0, idx)));
        }
      }
      const seenTick = new Set();
      tickIndexes.sort((a, b) => a - b);
      tickIndexes.forEach(idx => {
        if (seenTick.has(idx)) return;
        seenTick.add(idx);
        const time = uniqueTimes[idx];
        const xx = xForIndex(idx);
        const line = mk('line');
        line.setAttribute('x1', String(xx));
        line.setAttribute('x2', String(xx));
        line.setAttribute('y1', String(pad.top));
        line.setAttribute('y2', String(height - pad.bottom));
        line.setAttribute('opacity', '0.22');
        grid.appendChild(line);

        const label = mk('text');
        label.setAttribute('x', String(xx));
        label.setAttribute('y', String(height - pad.bottom + 20));
        label.setAttribute('text-anchor', 'middle');
        label.setAttribute('fill', '#6f8099');
        label.setAttribute('font-size', '11');
        label.textContent = shortDate.format(new Date(time));
        const labelTitle = mk('title');
        labelTitle.textContent = `Run ${idx + 1} · ${dateFormatter.format(new Date(time))}`;
        label.appendChild(labelTitle);
        svg.appendChild(label);
      });

      svg.appendChild(grid);

      const axis = mk('path');
      axis.setAttribute('d', `M ${pad.left} ${pad.top} V ${height - pad.bottom} H ${width - pad.right}`);
      axis.setAttribute('stroke', 'rgba(255,255,255,.35)');
      axis.setAttribute('fill', 'none');
      axis.setAttribute('stroke-width', '1.2');
      svg.appendChild(axis);

      const overlayGroup = mk('g');
      overlayGroup.setAttribute('pointer-events', 'none');
      svg.appendChild(overlayGroup);

      const crosshair = mk('line');
      crosshair.classList.add('chart-crosshair');
      crosshair.setAttribute('y1', String(pad.top));
      crosshair.setAttribute('y2', String(height - pad.bottom));
      crosshair.setAttribute('x1', String(pad.left));
      crosshair.setAttribute('x2', String(pad.left));
      crosshair.setAttribute('opacity', '0');
      overlayGroup.appendChild(crosshair);

      const markerGroup = mk('g');
      overlayGroup.appendChild(markerGroup);

      const plots = [];
      let colorIndex = 0;

      series.forEach(entry => {
        if (!entry.pts.length) return;
        const stroke = color(colorIndex++);

        const group = mk('g');
        svg.appendChild(group);

        const pts = entry.pts.map((pt, idx) => {
          const prev = idx > 0 ? entry.pts[idx - 1] : null;
          const delta = prev ? pt.elo - prev.elo : null;
          const timeMs = pt.t.getTime();
          return {
            time: pt.t,
            timeMs,
            elo: pt.elo,
            delta,
            x: x(timeMs),
            y: y(pt.elo),
            meta: entry.meta,
            color: stroke,
            runIndex: (indexByTime.get(timeMs) ?? 0) + 1
          };
        });

        const pathData = pts.map((pt, idx) => `${idx === 0 ? 'M' : 'L'} ${pt.x} ${pt.y}`).join(' ');
        const glow = mk('path');
        glow.setAttribute('d', pathData);
        glow.setAttribute('fill', 'none');
        glow.setAttribute('stroke', stroke);
        glow.setAttribute('stroke-width', '6');
        glow.setAttribute('stroke-linecap', 'round');
        glow.setAttribute('stroke-linejoin', 'round');
        glow.setAttribute('opacity', '.18');

        const line = mk('path');
        line.setAttribute('d', pathData);
        line.setAttribute('fill', 'none');
        line.setAttribute('stroke', stroke);
        line.setAttribute('stroke-width', '2.6');
        line.setAttribute('stroke-linecap', 'round');
        line.setAttribute('stroke-linejoin', 'round');

        group.appendChild(glow);
        group.appendChild(line);

        pts.forEach(pt => {
          const circle = mk('circle');
          circle.setAttribute('cx', String(pt.x));
          circle.setAttribute('cy', String(pt.y));
          circle.setAttribute('r', '3');
          circle.setAttribute('fill', stroke);
          circle.setAttribute('opacity', '.85');
          group.appendChild(circle);
        });

        const marker = mk('circle');
        marker.classList.add('chart-marker');
        marker.setAttribute('r', '5.2');
        marker.setAttribute('stroke', stroke);
        marker.style.display = 'none';
        markerGroup.appendChild(marker);

        const plot = { meta: entry.meta, color: stroke, points: pts, marker };
        pts.forEach(p => {
          p.plot = plot;
          p.hoverKey = String(p.timeMs);
        });
        plots.push(plot);
      });

      state.plots = plots;
      state.flat = plots.flatMap(plot => plot.points);
      state.flatSorted = state.flat.slice().sort((a, b) => a.x - b.x);

      if (!plots.length) return;

      plots.forEach(plot => {
        const item = document.createElement('div');
        item.className = 'chart-legend__item';
        item.style.setProperty('--legend-color', plot.color);

        const swatch = document.createElement('span');
        swatch.className = 'chart-legend__swatch';
        item.appendChild(swatch);

        const label = document.createElement('div');
        label.className = 'chart-legend__label';
        const iconEl = createIconElement(plot.meta.iconMarkup);
        if (iconEl) label.appendChild(iconEl);

        const textWrap = document.createElement('div');
        textWrap.className = 'chart-legend__text';
        const modelEl = document.createElement('span');
        modelEl.className = 'chart-legend__model';
        modelEl.textContent = plot.meta.model || 'Unknown';
        const companyEl = document.createElement('span');
        companyEl.className = 'chart-legend__company';
        companyEl.textContent = plot.meta.company || 'Unknown';
        textWrap.appendChild(modelEl);
        textWrap.appendChild(companyEl);

        label.appendChild(textWrap);
        item.appendChild(label);
        legend.appendChild(item);
      });

      function hideHover() {
        tooltip.classList.remove('visible');
        crosshair.setAttribute('opacity', '0');
        plots.forEach(plot => (plot.marker.style.display = 'none'));
        state.lastHoverKey = null;
      }

      function showAtPoint(point) {
        crosshair.setAttribute('opacity', '1');
        crosshair.setAttribute('x1', String(point.x));
        crosshair.setAttribute('x2', String(point.x));

        const sameTime = plots
          .map(plot => plot.points.find(p => p.timeMs === point.timeMs))
          .filter(Boolean)
          .sort((a, b) => b.elo - a.elo);

        plots.forEach(plot => {
          const match = plot.points.find(p => p.timeMs === point.timeMs);
          if (match) {
            plot.marker.style.display = 'block';
            plot.marker.setAttribute('cx', String(match.x));
            plot.marker.setAttribute('cy', String(match.y));
          } else {
            plot.marker.style.display = 'none';
          }
        });

        const runLabel = point.runIndex ? `Run ${point.runIndex}` : '';
        const timeLabel = dateFormatter.format(point.time);
        tooltipTime.textContent = runLabel ? `${runLabel} · ${timeLabel}` : timeLabel;
        tooltipSeries.innerHTML = '';
        sameTime.forEach(pt => {
          const row = document.createElement('div');
          row.className = 'chart-tooltip__row';

          const label = document.createElement('div');
          label.className = 'chart-tooltip__label';

          const bullet = document.createElement('span');
          bullet.className = 'chart-bullet';
          bullet.style.background = pt.color;
          label.appendChild(bullet);

          const modelEl = document.createElement('span');
          modelEl.className = 'chart-tooltip__model';
          modelEl.textContent = pt.meta.model || 'Unknown';
          label.appendChild(modelEl);

          const value = document.createElement('div');
          value.className = 'chart-tooltip__value';
          const eloEl = document.createElement('span');
          eloEl.className = 'chart-tooltip__elo';
          eloEl.textContent = Math.round(pt.elo).toString();
          value.appendChild(eloEl);

          const deltaEl = document.createElement('span');
          deltaEl.className = 'chart-tooltip__delta';
          if (Number.isFinite(pt.delta)) {
            const roundedDelta = Math.round(pt.delta);
            const sign = roundedDelta > 0 ? '+' : '';
            deltaEl.textContent = `${sign}${roundedDelta}`;
            if (roundedDelta > 0) {
              deltaEl.classList.add('positive');
            } else if (roundedDelta < 0) {
              deltaEl.classList.add('negative');
            } else {
              deltaEl.classList.add('neutral');
            }
          } else {
            deltaEl.textContent = '–';
            deltaEl.classList.add('neutral');
          }
          value.appendChild(deltaEl);

          row.appendChild(label);
          row.appendChild(value);
          tooltipSeries.appendChild(row);
        });

        const chartRect = chartWrap.getBoundingClientRect();
        const relX = (point.x / width) * chartRect.width;
        const relY = (point.y / height) * chartRect.height;
        const clampedX = Math.min(Math.max(relX, 72), chartRect.width - 72);
        const clampedY = Math.min(Math.max(relY, 78), chartRect.height - 18);

        tooltip.style.left = `${clampedX}px`;
        tooltip.style.top = `${clampedY}px`;
        tooltip.classList.add('visible');
      }

      function handlePointer(evt) {
        const ctm = svg.getScreenCTM();
        if (!ctm) return;
        const pt = svg.createSVGPoint();
        pt.x = evt.clientX;
        pt.y = evt.clientY;
        const svgPoint = pt.matrixTransform(ctm.inverse());
        if (svgPoint.x < pad.left || svgPoint.x > width - pad.right || svgPoint.y < pad.top || svgPoint.y > height - pad.bottom) {
          hideHover();
          return;
        }
        if (!state.flatSorted.length) {
          hideHover();
          return;
        }
        const sorted = state.flatSorted;
        let lo = 0;
        let hi = sorted.length - 1;
        while (lo < hi) {
          const mid = Math.floor((lo + hi) / 2);
          if (sorted[mid].x < svgPoint.x) {
            lo = mid + 1;
          } else {
            hi = mid;
          }
        }
        let best = null;
        let bestDist = Infinity;
        const start = Math.max(0, lo - 6);
        const end = Math.min(sorted.length - 1, lo + 6);
        for (let i = start; i <= end; i++) {
          const candidate = sorted[i];
          const dx = svgPoint.x - candidate.x;
          const dy = svgPoint.y - candidate.y;
          const dist = Math.hypot(dx, dy);
          if (dist < bestDist) {
            bestDist = dist;
            best = candidate;
          }
        }
        if (!best) {
          hideHover();
          return;
        }
        const hoverKey = best.hoverKey || String(best.timeMs);
        if (state.lastHoverKey === hoverKey) return;
        state.lastHoverKey = hoverKey;
        showAtPoint(best);
      }

      svg.addEventListener('pointermove', handlePointer);
      svg.addEventListener('pointerdown', handlePointer);
      svg.addEventListener('pointerenter', handlePointer);
      svg.addEventListener('pointerleave', hideHover);
    }

    function createFilterButton(key, label, iconMarkup) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'filter-chip';
      btn.setAttribute('data-key', key);
      const content = document.createElement('span');
      content.className = 'filter-chip__content';
      if (iconMarkup) {
        const iconEl = createIconElement(iconMarkup);
        if (iconEl) content.appendChild(iconEl);
      } else {
        const dot = document.createElement('span');
        dot.className = 'filter-chip__dot';
        content.appendChild(dot);
      }
      const textEl = document.createElement('span');
      textEl.className = 'filter-chip__text';
      textEl.textContent = label;
      content.appendChild(textEl);
      btn.appendChild(content);
      return btn;
    }

    function updateFilterButtons() {
      document.querySelectorAll('#companyFilters .filter-chip').forEach(btn => {
        const key = btn.getAttribute('data-key');
        const active = key === state.selectedCompany;
        btn.classList.toggle('active', active);
        btn.setAttribute('aria-pressed', active ? 'true' : 'false');
      });
    }

    function renderCompanyFilters() {
      const host = document.getElementById('companyFilters');
      if (!host) return;
      host.innerHTML = '';
      host.appendChild(createFilterButton('all', 'All companies'));
      state.companies.forEach(entry => {
        host.appendChild(createFilterButton(entry.key, entry.label, entry.iconMarkup));
      });
      updateFilterButtons();
    }

    function applyFilters() {
      const key = state.selectedCompany;
      const filtered = key === 'all'
        ? state.fullSeries
        : state.fullSeries.filter(entry => entry.meta.companyKey === key);
      const sorted = filtered.slice().sort((a, b) => {
        const aLast = a.pts.length ? a.pts[a.pts.length - 1].elo : -Infinity;
        const bLast = b.pts.length ? b.pts[b.pts.length - 1].elo : -Infinity;
        return bLast - aLast;
      });
      draw(sorted);
    }

    function bindFilterEvents() {
      const host = document.getElementById('companyFilters');
      if (!host || host.dataset.bound === 'true') return;
      host.addEventListener('click', evt => {
        const btn = evt.target.closest('button.filter-chip');
        if (!btn) return;
        const key = btn.getAttribute('data-key');
        if (!key || key === state.selectedCompany) return;
        state.selectedCompany = key;
        updateFilterButtons();
        applyFilters();
      });
      host.dataset.bound = 'true';
    }

    function handleResize() {
      clearTimeout(state.resizeTimer);
      state.resizeTimer = setTimeout(() => {
        if (state.currentSeries && state.currentSeries.length) {
          draw(state.currentSeries);
        } else {
          draw(state.currentSeries || []);
        }
        state.lastHoverKey = null;
      }, 150);
    }

    async function getJSON(url, fallback) {
      try {
        const r = await fetch(url);
        if (r.ok) return await r.json();
      } catch {}
      if (fallback) {
        try {
          const r2 = await fetch(fallback);
          if (r2.ok) return await r2.json();
        } catch {}
      }
      return { rows: [] };
    }

    async function load() {
      const data = await getJSON('/api/elo-history', '/web/data/elo-history.json');
      const rows = (data.rows || []).map(r => ({
        bot_id: r.bot_id,
        model: r.model,
        company: r.company,
        when: r.when,
        elo: r.elo
      }));
      const grouped = groupByBot(rows);
      state.fullSeries = grouped;
      state.companies = buildCompanyIndex(grouped);
      renderCompanyFilters();
      bindFilterEvents();
      if (!state.resizeBound) {
        state.resizeBound = handleResize;
        window.addEventListener('resize', state.resizeBound);
      }
      applyFilters();
    }
  </script>
</head>
<body>
  <header class="site-header">
    <div class="topnav">
      <a class="brand" href="/web/index.html" aria-label="PokerBench home">
        <span class="brand__mark logo-badge logo-badge--sm">
          <img src="/web/img/pokerBenchlogo.svg" alt="PokerBench logo"/>
        </span>
        <span class="brand__text">PokerBench</span>
      </a>
      <nav>
        <a class="pill" href="/web/leaderboard.html">Leaderboard</a>
        <a class="pill" href="/web/matrix.html">Matrix</a>
        <a class="pill" href="/web/elo.html">Elo</a>
        <a class="pill" href="/web/replay.html">Replay</a>
        <a class="pill" href="/web/history.html">History</a>
        <a class="pill" href="/web/about.html">About</a>
      </nav>
    </div>
  </header>

  <main class="page-content">
    <div class="wrap wrap--wide">
      <div class="card elo-card">
      <div class="elo-card__header">
        <div class="elo-card__intro">
          <div class="elo-card__brand">
            <span class="elo-card__logo logo-badge logo-badge--md">
              <img src="/web/img/pokerBenchlogo.svg" alt="PokerBench logo"/>
            </span>
            <div class="elo-card__heading">
              <h1>Elo Over Time</h1>
              <div class="muted">End-of-match Elo per bot across all duels.</div>
            </div>
          </div>
          <div class="match-legend elo-card__legend" id="eloMatchLegend" hidden aria-live="polite"></div>
        </div>
        <div class="elo-card__filters">
          <div id="companyFilters" class="filter-chips"></div>
        </div>
      </div>
      <div class="elo-card__body">
        <div class="elo-chart">
          <svg id="chart"></svg>
          <div class="chart-tooltip">
            <div class="chart-tooltip__time"></div>
            <div class="chart-tooltip__series"></div>
          </div>
        </div>
        <div id="legend" class="chart-legend"></div>
      </div>
      </div>
    </div>
  </main>

  <footer class="site-footer">
    <div class="site-footer__inner">
      <a class="site-footer__brand" href="/web/index.html">
        <span class="logo-badge logo-badge--sm">
          <img src="/web/img/pokerBenchlogo.svg" alt="PokerBench logo"/>
        </span>
        <span>PokerBench</span>
      </a>
      <nav class="site-footer__nav" aria-label="Footer">
        <a href="/web/leaderboard.html">Leaderboard</a>
        <a href="/web/matrix.html">Matrix</a>
        <a href="/web/history.html">History</a>
        <a href="/web/about.html">About</a>
        <a href="https://github.com/jackkayser2005/pokerBench" target="_blank" rel="noopener">GitHub</a>
      </nav>
      <p class="site-footer__copy">© 2025 PokerBench</p>
    </div>
  </footer>
</body>
</html>
